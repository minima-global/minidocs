"use strict";(self.webpackChunkminima_docs=self.webpackChunkminima_docs||[]).push([[2235],{3905:(t,e,n)=>{n.d(e,{Zo:()=>u,kt:()=>E});var a=n(7294);function o(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function r(t,e){var n=Object.keys(t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(t);e&&(a=a.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),n.push.apply(n,a)}return n}function l(t){for(var e=1;e<arguments.length;e++){var n=null!=arguments[e]?arguments[e]:{};e%2?r(Object(n),!0).forEach((function(e){o(t,e,n[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(n,e))}))}return t}function i(t,e){if(null==t)return{};var n,a,o=function(t,e){if(null==t)return{};var n,a,o={},r=Object.keys(t);for(a=0;a<r.length;a++)n=r[a],e.indexOf(n)>=0||(o[n]=t[n]);return o}(t,e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(t);for(a=0;a<r.length;a++)n=r[a],e.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(t,n)&&(o[n]=t[n])}return o}var c=a.createContext({}),s=function(t){var e=a.useContext(c),n=e;return t&&(n="function"==typeof t?t(e):l(l({},e),t)),n},u=function(t){var e=s(t.components);return a.createElement(c.Provider,{value:e},t.children)},d="mdxType",m={inlineCode:"code",wrapper:function(t){var e=t.children;return a.createElement(a.Fragment,{},e)}},p=a.forwardRef((function(t,e){var n=t.components,o=t.mdxType,r=t.originalType,c=t.parentName,u=i(t,["components","mdxType","originalType","parentName"]),d=s(n),p=o,E=d["".concat(c,".").concat(p)]||d[p]||m[p]||r;return n?a.createElement(E,l(l({ref:e},u),{},{components:n})):a.createElement(E,l({ref:e},u))}));function E(t,e){var n=arguments,o=e&&e.mdxType;if("string"==typeof t||o){var r=n.length,l=new Array(r);l[0]=p;var i={};for(var c in e)hasOwnProperty.call(e,c)&&(i[c]=e[c]);i.originalType=t,i[d]="string"==typeof t?t:o,l[1]=i;for(var s=2;s<r;s++)l[s]=n[s];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}p.displayName="MDXCreateElement"},51:(t,e,n)=>{n.r(e),n.d(e,{assets:()=>c,contentTitle:()=>l,default:()=>m,frontMatter:()=>r,metadata:()=>i,toc:()=>s});var a=n(7462),o=(n(7294),n(3905));const r={sidebar_position:2},l="Vestr",i={unversionedId:"buildonminima/dappcontracts/vestr",id:"buildonminima/dappcontracts/vestr",title:"Vestr",description:"About",source:"@site/docs/buildonminima/dappcontracts/vestr.md",sourceDirName:"buildonminima/dappcontracts",slug:"/buildonminima/dappcontracts/vestr",permalink:"/docs/buildonminima/dappcontracts/vestr",draft:!1,editUrl:"https://github.com/minima-global/minidocs/docs/buildonminima/dappcontracts/vestr.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Future Cash",permalink:"/docs/buildonminima/dappcontracts/futurecash"},next:{title:"Minima Terms and Conditions",permalink:"/docs/terms/minimatermsandconditions"}},c={},s=[{value:"About",id:"about",level:2},{value:"Use Cases",id:"use-cases",level:2},{value:"Smart Contract",id:"smart-contract",level:2},{value:"State Variables",id:"state-variables",level:2},{value:"Contract Address",id:"contract-address",level:2},{value:"Calculations",id:"calculations",level:2},{value:"Sending coins to the contract",id:"sending-coins-to-the-contract",level:2},{value:"Example",id:"example",level:2},{value:"Source code",id:"source-code",level:2}],u={toc:s},d="wrapper";function m(t){let{components:e,...n}=t;return(0,o.kt)(d,(0,a.Z)({},u,n,{components:e,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"vestr"},"Vestr"),(0,o.kt)("h2",{id:"about"},"About"),(0,o.kt)("p",null,"Vestr is a smart contract that releases coins to a wallet in equal amounts at specified time intervals e.g. daily, weekly, monthly over a set period of time - a vesting contract."),(0,o.kt)("h2",{id:"use-cases"},"Use Cases"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Vesting contracts for investors")," - to lock away ",(0,o.kt)("strong",{parentName:"li"},"investor coins")," according to a vesting schedule, to be released equally over a certain time period."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Pocket money")," - to lock away a set amount of coins, releasing them at a predefined schedule."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Proof of inaccessibility")," - to lock away project funds to prove they are only released at certain intervals. (This is known as TVL, this increases a project\u2019s liability)")),(0,o.kt)("h2",{id:"smart-contract"},"Smart Contract"),(0,o.kt)("p",null,"Below is the Vestr smart contract. The hash of this script is the address that coins can be sent to, along with defined state variables, to create the vesting contract."),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"@")," Represents a global variable"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"PREVSTATE")," represents the state variables stored in the coin that is locked in the Vestr contract"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"STATE")," represents a state variable given at the time the transaction is constructed"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsx"},"  LET unlockaddress = PREVSTATE(0) // withdrawing address of contract\n  LET totallockedamount = PREVSTATE(1) // the original total amount locked\n  LET startblock = PREVSTATE(2) // the starting block of the contract\n  LET finalblock = PREVSTATE(3) // the final block of the contract\n  LET minblockwait = PREVSTATE(4) // the minimum block time we must wait between each collection\n\n  ASSERT SAMESTATE(0 8) // Ensure that all state variables are the same transaction to transaction\n\n  ASSERT PREVSTATE(199) EQ STATE(199) // Make sure that state variables 199 -> 199 are the same\n\n  // If current block time greater than the final then allow collection for all\n  IF @BLOCK GTE finalblock THEN\n    IF VERIFYOUT (@INPUT unlockaddress @AMOUNT @TOKENID false) THEN RETURN TRUE ENDIF\n  ENDIF\n\n  // If current block less than the starting block then reject execution\n  IF @BLOCK LT startblock THEN RETURN FALSE ENDIF\n\n  // If the coin's age is less than the minimum block time wait then reject execution\n  IF @COINAGE LT minblockwait THEN RETURN FALSE ENDIF\n\n    // calculate the total duration of the contract  \n  LET totalduration = finalblock - startblock\n\n  // If the total duration is less than zero then that means the contract has finished\n  // now allow them to collect the full amount\n  IF totalduration LTE 0 THEN \n    LET blockamount = @AMOUNT \n  ELSE\n  // otherwise make it so they can collect a partial according to the duration\n    LET blockamount = SIGDIG(2 (totallockedamount / totalduration))\n  ENDIF\n\n  // We use SIGDIG(2 (amount)) which returns us the amount to 2 significant digits\n  // this will evade mis-calculations and ignores the less significant digits\n  // in the total amount they can collect\n  // this is done because sometimes as they are constructing the contract\n  // the block time recorded in this contract vs real time changes\n  // and so this will error the contract\n\n  // Let's calculate how much they can collect on this block\n  LET owedamounttime = @BLOCK - startblock\n  LET owedamountminima = owedamounttime * blockamount\n  LET alreadycollected = totallockedamount - @AMOUNT\n  LET cancollect = SIGDIG(2 (owedamountminima - alreadycollected))\n\n  // If the cancollect amount is less than 0 then reject\n  IF cancollect LTE 0 THEN RETURN FALSE ENDIF\n\n  // If the cancollect is greater than the coin amount then let them collect all\n  IF cancollect GT @AMOUNT THEN LET cancollect = @AMOUNT ENDIF\n\n  // Let's verify all the outputs are valid\n  LET payout = GETOUTAMT(@INPUT)\n\n  IF GETOUTADDR(@INPUT) NEQ unlockaddress THEN RETURN FALSE ENDIF //If the output coin is not being sent to the unlock address, return FALSE\n  IF GETOUTTOK(@INPUT) NEQ @TOKENID THEN RETURN FALSE ENDIF //If the output coin does not match the tokenid of the input, return FALSE\n  IF payout GT cancollect THEN RETURN FALSE ENDIF //If the amount to payout is greater than the amount available to collect, return FALSE\n  IF GETOUTKEEPSTATE(@INPUT) NEQ FALSE THEN RETURN FALSE ENDIF //If the output coin does not have a storestate value of FALSE, return FALSE\n\n  LET change = @AMOUNT - payout\n\n  // If there is no change then ignore check\n  IF change LTE 0 THEN RETURN TRUE ENDIF\n\n  // Now verify that the opposing output is true\n  RETURN VERIFYOUT(@INPUT+1 @ADDRESS change @TOKENID TRUE)\n")),(0,o.kt)("h2",{id:"state-variables"},"State Variables"),(0,o.kt)("p",null,"The following state variables must be provided with the transaction"),(0,o.kt)("table",null,(0,o.kt)("thead",{parentName:"table"},(0,o.kt)("tr",{parentName:"thead"},(0,o.kt)("th",{parentName:"tr",align:null},"State Variable"),(0,o.kt)("th",{parentName:"tr",align:null},"Description"))),(0,o.kt)("tbody",{parentName:"table"},(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"0"),(0,o.kt)("td",{parentName:"tr",align:null},"Collector\u2019s address")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"1"),(0,o.kt)("td",{parentName:"tr",align:null},"Locking up amount")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"2"),(0,o.kt)("td",{parentName:"tr",align:null},"Start contract block height")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"3"),(0,o.kt)("td",{parentName:"tr",align:null},"End contract block height")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"4"),(0,o.kt)("td",{parentName:"tr",align:null},"Minimum time user must wait between collections (Blocks)")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"5"),(0,o.kt)("td",{parentName:"tr",align:null},"Current time (unix)")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"6"),(0,o.kt)("td",{parentName:"tr",align:null},"Starting block (unix)")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"7"),(0,o.kt)("td",{parentName:"tr",align:null},"Grace period (unix) (This is state variable 4 but in unix)")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"8"),(0,o.kt)("td",{parentName:"tr",align:null},"End block (unix)")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"199"),(0,o.kt)("td",{parentName:"tr",align:null},"Unique Identifier for Contract")))),(0,o.kt)("h2",{id:"contract-address"},"Contract Address"),(0,o.kt)("p",null,"0x address: ",(0,o.kt)("inlineCode",{parentName:"p"},"0x3C432D5099AB27EA901079EF54D9A97AB4DB3BD1CFFF670296C31B7C83C1C8BE")," ",(0,o.kt)("br",null),"\nMx address: ",(0,o.kt)("inlineCode",{parentName:"p"},"MxG081S8CMY16DB4VY9043PTTADJABQMJDJNKEFVTJG55M33DU87GE8NQKDQ4CM")),(0,o.kt)("h2",{id:"calculations"},"Calculations"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsx"},'// This is a smart contract script written just to use the\n// checkMaths Minima command to do the calculation for us using KISSVM Math\n// This will ensure precision\n\n  LET totallockedamount=PREVSTATE(1) \n  LET startblock=PREVSTATE(2) \n  LET finalblock=PREVSTATE(3) \n  LET minblockwait=PREVSTATE(4) \n  LET mustwaitblocks="0"\n  LET mustwait= (@BLOCK - @COINAGE) GT "0" AND minblockwait GT (@BLOCK - @COINAGE)\n  LET contractexpired = @BLOCK GTE finalblock\n  IF mustwait EQ TRUE THEN LET mustwaitblocks=minblockwait - (@BLOCK - @COINAGE) ENDIF\n  \n  LET coinsage=@COINAGE  \n  LET cliffed=@BLOCK LT startblock \n  LET totalduration=finalblock-startblock \n  IF totalduration LTE 0 THEN LET blockamount=@AMOUNT ELSE LET blockamount=SIGDIG(2 (totallockedamount/totalduration)) ENDIF \n  LET owedamounttime=@BLOCK-startblock \n  LET owedamountminima=owedamounttime*blockamount \n  LET alreadycollected=totallockedamount-@AMOUNT \n  LET cancollect=SIGDIG(2 (owedamountminima - alreadycollected)) \n  IF cancollect GT @AMOUNT THEN LET cancollect=@AMOUNT ENDIF \n  LET change=@AMOUNT-cancollect LET totalsum = change + cancollect LET totalinput = @AMOUNT\n  \n  IF contractexpired EQ TRUE THEN LET mustwait=FALSE ENDIF\n  IF contractexpired EQ TRUE THEN LET cancollect=@AMOUNT ENDIF\n')),(0,o.kt)("p",null,"We then use the\xa0",(0,o.kt)("inlineCode",{parentName:"p"},"runscript"),"\xa0method to calculate this for us, this\xa0",(0,o.kt)("strong",{parentName:"p"},"only"),"\xa0runs the calculation"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsx"},'// you add the script we mentioned above, the previous state variables (stored in the coin) as if it was the actual coin, and we add the globals that the contract requires, e.g @BLOCK\n// This contract requires globals: @AMOUNT, @BLOCK, @COINAGE \nrunscript script:"theAboveScript" prevstate:addAllPreviousState globals:addAllGlobals\n')),(0,o.kt)("h2",{id:"sending-coins-to-the-contract"},"Sending coins to the contract"),(0,o.kt)("p",null,"To send coins to the Vestr contract, we can use the ",(0,o.kt)("inlineCode",{parentName:"p"},"send")," command, providing the following parameters:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"debug:false")," - debug logs off"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"password:")," - the node password if locked"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"amount:")," - the total amount to send to the Vestr contract"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"address:")," - the Vestr contract address"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"tokenid:")," - the tokenid of the token being sent to the contract. Default 0x00 for Minima"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"state:")," - list of state variables as defined above"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"burn:")," - optional amount of Minima to burn")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},'send debug:false \npassword: \namount: \naddress: \ntokenid: \nstate:{"0":"address","1":"amount","2":"startContractBlockHeight", "3":"endContractBlockHeight","4":"minimumTimeUserMustWaitToCollectAgain","5":"currenttime","6":"startblockunixtime","7":"graceperiodunix","8":"endblockunixtime", "199":"contractuid"\nburn:\n')),(0,o.kt)("h2",{id:"example"},"Example"),(0,o.kt)("p",null,"Example coin locked in Vestr contract"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsx"},' {\n    "coinid":"0x8102204B758D6B3FBD755B3B599042FB78D34936F0D0F22FD380719033A42CFD",\n    "amount":"450",\n    "address":"0x3C432D5099AB27EA901079EF54D9A97AB4DB3BD1CFFF670296C31B7C83C1C8BE",\n    "miniaddress":"MxG081S8CMY16DB4VY9043PTTADJABQMJDJNKEFVTJG55M33DU87GE8NQKDQ4CM",\n    "tokenid":"0x00",\n    "token":null,\n    "storestate":true,\n    "state":[{\n      "port":0,\n      "type":1,\n      "data":"0x73555898D7E4DD6C1B45864A61C952DB3F05FBA300BDDB381A2F219E999F7061"\n    },\n    {\n      "port":1,\n      "type":2,\n      "data":"450"\n    },\n    {\n      "port":2,\n      "type":2,\n      "data":"507343"\n    },\n    {\n      "port":3,\n      "type":2,\n      "data":"2373583"\n    },\n    {\n      "port":4,\n      "type":2,\n      "data":"311040"\n    },\n    {\n      "port":5,\n      "type":2,\n      "data":"1698927118376"\n    },\n    {\n      "port":6,\n      "type":2,\n      "data":"1698927118376"\n    },\n    {\n      "port":7,\n      "type":2,\n      "data":"4320"\n    },\n    {\n      "port":8,\n      "type":2,\n      "data":"1793621518376"\n    },\n    {\n      "port":199,\n      "type":1,\n      "data":"0x155E60B2D962F22EBC578742C80BA4BD144B4C676FAA05738AF239A802C63DF2"\n    }],\n    "spent":false,\n    "mmrentry":"444191",\n    "created":"507345"\n  }\n')),(0,o.kt)("h2",{id:"source-code"},"Source code"),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://github.com/minima-global/vestr/"},"https://github.com/minima-global/vestr/")))}m.isMDXComponent=!0}}]);