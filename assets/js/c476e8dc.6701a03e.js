"use strict";(self.webpackChunkminima_docs=self.webpackChunkminima_docs||[]).push([[7123],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>m});var r=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var s=r.createContext({}),p=function(e){var t=r.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=p(e.components);return r.createElement(s.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,a=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),d=p(n),m=o,h=d["".concat(s,".").concat(m)]||d[m]||u[m]||a;return n?r.createElement(h,i(i({ref:t},c),{},{components:n})):r.createElement(h,i({ref:t},c))}));function m(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=n.length,i=new Array(a);i[0]=d;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:o,i[1]=l;for(var p=2;p<a;p++)i[p]=n[p];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},1874:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>u,frontMatter:()=>a,metadata:()=>l,toc:()=>p});var r=n(7462),o=(n(7294),n(3905));const a={sidebar_position:11},i="MAST Contracts",l={unversionedId:"buildonminima/txntutorial/layer1/mastcontract",id:"buildonminima/txntutorial/layer1/mastcontract",title:"MAST Contracts",description:"MAST stands for Merkelized Abstract Syntax Tree. It is a technique that not only allows for very large scripts to be used, it also greatly increases privacy.",source:"@site/docs/buildonminima/txntutorial/layer1/mastcontract.md",sourceDirName:"buildonminima/txntutorial/layer1",slug:"/buildonminima/txntutorial/layer1/mastcontract",permalink:"/docs/buildonminima/txntutorial/layer1/mastcontract",draft:!1,editUrl:"https://github.com/minima-global/minidocs/docs/buildonminima/txntutorial/layer1/mastcontract.md",tags:[],version:"current",sidebarPosition:11,frontMatter:{sidebar_position:11},sidebar:"tutorialSidebar",previous:{title:"MultiSig MultiCoin",permalink:"/docs/buildonminima/txntutorial/layer1/multisigmulticoin"},next:{title:"The Vault",permalink:"/docs/buildonminima/txntutorial/layer1/thevault"}},s={},p=[],c={toc:p};function u(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,r.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"mast-contracts"},"MAST Contracts"),(0,o.kt)("p",null,"MAST stands for ",(0,o.kt)("strong",{parentName:"p"},"M"),"erkelized ",(0,o.kt)("strong",{parentName:"p"},"A"),"bstract ",(0,o.kt)("strong",{parentName:"p"},"S"),"yntax ",(0,o.kt)("strong",{parentName:"p"},"T"),"ree. It is a technique that not only allows for very large scripts to be used, it also greatly increases privacy. "),(0,o.kt)("p",null,"Instead of providing the entire script - you can MAST sections of it and only present the information required for the path of execution. "),(0,o.kt)("p",null,"It involves making hash trees of values, providing the root of the tree, the leaf node and accompanying proof. The proof grows as log(n) for n - standard binary hash tree."),(0,o.kt)("p",null,"In other words.. You have this script :"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"IF SIGNEDBY(0xFF) THEN\n//RUN SOME CODE - CODEBLOCK 1\nELSEIF @BLOCK GT 100 THEN\n//RUN SOME OTHER CODE - CODEBLOCK 2\nENDIF\n")),(0,o.kt)("p",null,"If ",(0,o.kt)("inlineCode",{parentName:"p"},"codeblock1")," is run then you never need to know what was in ",(0,o.kt)("inlineCode",{parentName:"p"},"codeblock2"),". That code is never executed. These blocks of code could be large, very large. This way you reduce the amount of data needed to be sent with the transaction, decreasing size and increasing privacy. The code could be MegaBytes in size.. all that matters is that the path of execution through the code is below the Minima KISSVM limit. ",(0,o.kt)("strong",{parentName:"p"},"Currently this is set to 512 operations.")),(0,o.kt)("admonition",{type:"note"},(0,o.kt)("p",{parentName:"admonition"},"Since a MAST block is a hash tree of different values.. The leaf nodes of the tree are the allowed values.. so you can have ",(0,o.kt)("em",{parentName:"p"},"millions")," of possible script blocks, all accessed via a different merkle proof to root. ")),(0,o.kt)("p",null,"Say you wanted to have a 1 of 10,000 multisig. You could not add 10,000 public keys to a script - as it would make the transaction too large to send over the network. But - each leaf node could be a different ",(0,o.kt)("inlineCode",{parentName:"p"},"SIGNEDBY")," code block, and you would present that code with the correct proof to be allowed to spend that coin. "),(0,o.kt)("p",null,"Or.. perhaps you could use this technique to check for valid game states - tic tac toe would require 3",(0,o.kt)("sup",null,"9")," possible final states.. and when you play the game you provide the winning state (a leaf node + proof) which is checked in the script. (More on that later.. )"),(0,o.kt)("p",null,"The way you would package this up is:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"IF SIGNEDBY(0xFF) THEN\nMAST 0x72BE56DFD48B785139A72512FEAAC7E339B8F48132E9B9340A248EFC00F4A5DA\nELSEIF @BLOCK GT 100 THEN\nMAST 0xFA1B16685F09FA56581614AC55E731697C46926392129F3A6BF8FA5EE202A251\nENDIF\n")),(0,o.kt)("p",null,"Then you provide the script proof for the particular MAST block. You can have MAST blocks inside other MAST blocks of course.\nLet's now go through a complete example. Let's create a MAST block.."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'mmrcreate nodes:["RETURN TRUE","RETURN FALSE"]\n')),(0,o.kt)("p",null,"This will create an MMR tree, with 2 leaf nodes. You can check the proofs with the data provided by ",(0,o.kt)("inlineCode",{parentName:"p"},"mmrcreate"),".."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'mmrproof data:"RETURN TRUE" proof:0x00000101000000002068073D52B5CE60A854BA2AA42CFB2E27D9FADFC9C4F7EA52F E48E58F604EBEC7 root:0x0E321692DA8996A833F88EC8A73F3AA8A5E949AD12FF48207130C7AE6F9DC115\n')),(0,o.kt)("p",null,"The root value is the value you give MAST. The above returns true.. but you could also use :"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'mmrproof data:"RETURN FALSE" proof:0x00000101010000002072BE56DFD48B785139A72512FEAAC7E339B8F48132E9B9340A2 48EFC00F4A5DA root:0x0E321692DA8996A833F88EC8A73F3AA8A5E949AD12FF48207130C7AE6F9DC115\n')),(0,o.kt)("p",null,"This will also return true. What is important to note is that BOTH have the same root. It is the merkle proof that is different for both."),(0,o.kt)("p",null,"So how to check this in a script.."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'runscript script:"MAST 0x0E321692DA8996A833F88EC8A73F3AA8A5E949AD12FF48207130C7AE6F9DC115" extrascripts:{"RETURN TRUE":"0x00000101000000002068073D52B5CE60A854BA2AA42CFB2E27D9FADFC9C4F7EA5 2FE48E58F604EBEC7"}\n')),(0,o.kt)("p",null,"You could create interesting scripts with multiple ways of them being executed.. You can even use these merkelized proofs as state variables and check them yourself in script.\nIn this case.."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'runscript script:"LET script=[RETURN TRUE] LET proof=0x00000101000000002068073D52B5CE60A854BA2AA42CFB2E27D9FADFC9C4F7EA52F E48E58F604EBEC7 LET root=0x0E321692DA8996A833F88EC8A73F3AA8A5E949AD12FF48207130C7AE6F9DC115 ASSERT PROOF(script proof root) EXEC script"\n')),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"PROOF")," takes the same arguments as ",(0,o.kt)("inlineCode",{parentName:"p"},"mmrproof"),". "),(0,o.kt)("p",null,"You could put those variables as state variables and have a generic contract that can run ANY of the leaf node scripts you create in your tree.. like so:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'runscript script:"LET script=STATE(0) LET proof=STATE(1) ASSERT PROOF(script proof 0x0E321692DA8996A833F88EC8A73F3AA8A5E949AD12FF48207130C7AE6F9DC115) EXEC script" state:{"0":"[RETURN TRUE]",  "1":"0x00000101000000002068073D52B5CE60A854BA2AA42CFB2E27D9FADFC9C4F7EA52FE 48E58F604EBEC7"}\n')),(0,o.kt)("p",null,"You would still want a signature - or put that as a requirement in the leaf node script."),(0,o.kt)("p",null,"When adding extra scripts to a custom txn you can use ",(0,o.kt)("inlineCode",{parentName:"p"},"txnscript"),". Here is an example."),(0,o.kt)("p",null,"First let's calculate the simplest MAST script"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'scripts action:clean script:"RETURN TRUE"\n')),(0,o.kt)("p",null,"This will return the clean version.. And the address: "),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"0x72BE56DFD48B785139A72512FEAAC7E339B8F48132E9B9340A248EFC00F4A5DA\n")),(0,o.kt)("p",null,"Now send funds to it."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"send amount:1 address:0x459C3CE5EDDF8E78F901A7289981640A8A3A83E2B95558435BFEBBD674CF8D50\n")),(0,o.kt)("p",null,"Now wait for those to clear. You can use ",(0,o.kt)("inlineCode",{parentName:"p"},"coins relevant:true")," to see your coins AND to get the CoinID."),(0,o.kt)("p",null,"Now construct a txn.."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"txncreate id:txnmast\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"txninput id:txnmast coinid:0xB2F2E123F6A1E00E956390B3BEDAF48CB475279CD73EC7D4BD2E0D56823A09A3\n")),(0,o.kt)("p",null,"Your coinid will be different.. "),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"txnoutput id:txnmast address:0xFF amount:1\n")),(0,o.kt)("p",null,"And now we should have a simple txn."),(0,o.kt)("p",null,"Try and post it."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"txnpost id:txnmast auto:true\n")),(0,o.kt)("p",null,"We use ",(0,o.kt)("inlineCode",{parentName:"p"},"auto:true")," which is the same as ",(0,o.kt)("inlineCode",{parentName:"p"},"txnbasics"),".\nIt FAILS!.. On the console it will print.."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"'Script FAIL 0 MAST 0x72BE56DFD48B785139A72512FEAAC7E339B8F48132E9B9340A248EFC00F4A5DA'\n")),(0,o.kt)("p",null,"This is because it does not know how to handle the MAST script.. You need to add the scripts that MAST uses. You can clear all the witness data with:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"txnclear id:txnmast\n")),(0,o.kt)("p",null,"Now add the details about that script:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'txnscript id:txnmast scripts:{"RETURN TRUE":""}\n')),(0,o.kt)("p",null,"The JSON holds the script and the proof. If it is a single script, and not one created with mmrcreate, just leave the proof blank. If it is an mmrcreate script, copy the proof in."),(0,o.kt)("p",null,"Now the transaction knows what that MAST script is.. So try and post it again.."),(0,o.kt)("p",null,"And this time it WORKS!"))}u.isMDXComponent=!0}}]);